# DirectSound Driver Surface Inventory

## AudioSystemMaster registration
- `AUD_DSoundDriver.cpp` exposes a global `AudioSystemMaster` instance named `AudioSystemDSD` that describes the DirectSound backend for the WPAudio core. The struct records the driver name, property flags, initialization stamp, and pointers to the driver entry points (`audioLoad`, `audioUnload`, `audioOpen`, `audioClose`) alongside the channel-level `AudioDriver` vtable used by `AudioDevice` instances.【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L243-L255】【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L281-L301】
- During `AudioLoadSystem`, WPAudio calls `audioCreateSystem`, which stores the master pointer on the new `AudioSystem` object and immediately invokes `master->load`. A successful load marks the master as active and links the system into the global list so it can later be mapped to logical audio units.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Device.cpp†L321-L349】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Device.cpp†L627-L664】

## System lifetime hooks
- **Load (`audioLoad`)** – Creates the DirectSound device (`DirectSoundCreate`), elevates the cooperative level, reports that the system exposes a single logical unit, and ensures the global mixer thread exists. The thread is created with `AUD_service_device` as its callback and is locked to the driver until the device is opened.【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L1333-L1368】
- **Unload (`audioUnload`)** – Releases the DirectSound object, tears down the service thread when no devices hold the thread lock, and shuts down the Miles ASI subsystem used for streaming decode.【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L1376-L1398】

## Device lifetime hooks
- When WPAudio needs a device, `audioCreateDevice` allocates an `AudioDevice`, binds the driver's `AudioDriver` table, and defers hardware setup to `master->open`. Failure to open propagates cleanup through `audioDestroyDevice` to call `master->close`.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Device.cpp†L211-L267】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Device.cpp†L274-L290】
- **Open (`audioOpen`)** – Configures device-level timing intervals, associates the DirectSound service thread with the device, creates and formats the primary DirectSound buffer, and starts it looping. The routine also records the frame, oversampling, and lag characteristics that the mixer loop expects downstream.【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L1405-L1459】
- **Close (`audioClose`)** – Detaches the device from the service thread and releases the primary buffer to stop playback before the `AudioDevice` is destroyed.【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L1467-L1479】

## Servicing callbacks
- The mixer thread created during `audioLoad` dispatches into `AUD_service_device`, which the driver registers as the polling routine. The callback pulls the current `AudioDevice`, verifies channel-list locks, advances service timers, and iterates every playing `AudioChannel`. Active channels either request new data via `audioCheck`/`AUD_update_buffer` or are stopped when exhausted. After channel processing, the routine notifies the higher-level device handler so attribute propagation stays in sync.【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L1333-L1368】【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L660-L715】
- Because the thread is owned by the driver, `audioLoad` and `audioOpen` coordinate access through `LockAcquire`/`AUD_ThreadSetData`, while `audioClose` clears the association. A backend replacement must provide equivalent hooks so the service loop can be reimplemented or redirected to a new audio engine.

## Implications for backend replacement
- The existing `AudioSystemMaster` contract isolates the backend-specific work to the `load`/`unload`/`open`/`close` quartet plus the service thread callback. Replicating this surface with a cross-platform engine (e.g., SFML) means supplying alternative implementations for these hooks and binding them to the WPAudio core through a new `AudioSystemMaster` instance.

## AudioChannel lifecycle expectations
- **Creation and registration.** `AudioDeviceCreateChannel` ensures the device stays within its `maxChannels` quota, invokes `audioChannelCreate`, and links the new `AudioChannel` into the device’s channel list. `audioChannelCreate` allocates the struct, resets control/attribute state via `audioChannelMakeStandard`, copies the device’s default format, and immediately hands the object to the driver’s `openChannel` hook so backend resources (e.g., buffers) are ready before the channel is exposed.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Device.cpp†L1075-L1108】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Device.cpp†L392-L406】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Channel.cpp†L106-L204】 Any failure during this phase calls the driver’s `closeChannel` and frees the partially constructed channel.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Channel.cpp†L133-L165】
- **Reservation and ownership.** Devices choose channels by type through `AudioDeviceGetChannel`, which prioritizes free voices, then paused ones, then the quietest low-priority playing voice for possible stealing. Once selected, `AudioChannelReserve`, `AudioChannelUse`, and their counterparts mark the `AudioControl.Status` bits (`mAUDIO_CTRL_ALLOCATED`, `mAUDIO_CTRL_INUSE`) so higher-level systems can avoid clobbering in-flight playback or can intentionally recycle channels when priority rules demand it.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Device.cpp†L1186-L1309】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Channel.cpp†L389-L588】 Releasing a channel restores the default callback set (`audioChannelMakeStandard`) so future consumers start from a known state.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Channel.cpp†L173-L204】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Channel.cpp†L423-L436】
- **Sample preparation and start.** When a caller binds an `AudioSample`, `AudioChannelSetSample` primes the channel’s frame pointers so the driver can pull PCM from either a linked-list of `AudioFrame`s or a flat buffer. `AudioChannelStart` refuses to run unless a sample is present, recalculates the effective attribute stack (channel, group, compositor, fade, SFX, device), then locks the driver and executes its `start` callback, raising the `mAUDIO_CTRL_PLAYING` bit on success. Stop, pause, and resume mirror this pattern by invoking the corresponding driver hook under lock, clearing or toggling the playback bits, and optionally firing user callbacks like `CB_Stop`.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Channel.cpp†L596-L666】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Channel.cpp†L462-L527】
- **Attribute propagation.** Outside the driver thread, each `AudioDevice` runs `audioDeviceHandler` to keep per-channel gains and pitch in sync with time-varying controls. The handler recomputes `AudioChannel.attribs` from channel-, group-, composition-, fade-, SFX-, and device-level `AudioAttribs`, then calls the driver’s `update` hook whenever any layer reports a change. New backends must honor this contract so volume, pan, and pitch adjustments propagate even while a channel is playing.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Device.cpp†L466-L530】
- **Driver-serviced streaming.** The DirectSound backend’s `AUD_fill_buffer` asks each channel’s `drvCBNextFrame`/`drvCBNextSample` callbacks for more PCM whenever the hardware buffer needs data. The defaults implemented in `audioChannelNextFrame` and `audioChannelNextSample` advance through queued `AudioFrame`s, handle loop counts, and enqueue additional buffers via the driver’s `queueIt` hook before handing silence back when the sample is exhausted. `AUD_update_buffer` schedules these fetches based on write cursor drift, and `AUD_channel_stop` finishes playback by stopping the DirectSound buffer and calling `drvCBSampleDone`, which resets control bits (`audioChannelSampleDone`) and fires any user completion callback. A replacement backend must provide comparable polling, buffer submission, and completion notifications so the higher-level code can continue to stream and recycle channels transparently.【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L1100-L1254】【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L1262-L1325】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Channel.cpp†L262-L378】
- **Destruction.** Destroying a channel stops playback, detaches it from the device list, and calls the driver’s `closeChannel` before freeing the allocation, ensuring backend resources are reclaimed when the channel pool shrinks.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Channel.cpp†L443-L666】

## Streaming pipeline expectations
- **Stream buffer construction.** `AUD_StreamBuffering` exposes a reusable ring buffer (`STM_STREAM`) composed of one or more `STM_SBUFFER` nodes. Streams are allocated with `STM_StreamCreate`, which initializes lock state and accessor records. Buffers are provisioned via `STM_SBufferCreate` (allocates aligned PCM storage) and linked into the stream with `STM_StreamAddSBuffer`/`STM_StreamCreateSBuffers`, while `STM_StreamReset`/`STM_StreamDestroyBuffers` recycle state between uses.【F:Generals/Code/Libraries/Source/WPAudio/AUD_StreamBuffering.cpp†L327-L395】【F:Generals/Code/Libraries/Source/WPAudio/AUD_StreamBuffering.cpp†L417-L462】【F:Generals/Code/Libraries/Source/WPAudio/AUD_StreamBuffering.cpp†L572-L632】
- **Accessor lifecycle and flow control.** Streams expose paired accessors (`vSTM_ACCESS_ID_IN` and `_OUT`) that act like producer/consumer cursors. `STM_StreamAcquireAccess` locks a view for exclusive use, initializes the cursor if this is the first acquisition, and returns a handle that can call `STM_AccessGetBlock` to expose the next contiguous region, `STM_AccessAdvance`/`STM_AccessUpdate` to consume or release bytes, and `STM_AccessFileTransfer`/`STM_AccessTransfer` to move data between the stream and caller-provided buffers or files.【F:Generals/Code/Libraries/Source/WPAudio/AUD_StreamBuffering.cpp†L470-L520】【F:Generals/Code/Libraries/Source/WPAudio/AUD_StreamBuffering.cpp†L752-L909】【F:Generals/Code/Libraries/Source/WPAudio/AUD_StreamBuffering.cpp†L917-L1152】 Upstream byte counters (`bytes_in`/`bytes_out`) ensure writers only fill available capacity (`STM_StreamTotalBytesTillFull`) while readers loop seamlessly across chained buffers.【F:Generals/Code/Libraries/Source/WPAudio/AUD_StreamBuffering.cpp†L528-L590】【F:Generals/Code/Libraries/Source/WPAudio/AUD_StreamBuffering.cpp†L985-L1094】
- **AudioStreamer setup.** `AudioStreamerCreate` reserves a dedicated `AudioChannel`, installs streaming callbacks (`streamNextFrame`, `streamSampleDone`, `streamStop`), creates a backing `STM_STREAM`, and registers the streamer with the high-priority refill thread so it can be serviced outside the mixer tick.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Streamer.cpp†L429-L520】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Streamer.cpp†L160-L218】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Streamer.cpp†L303-L390】
- **Prefill and playback start.** When `AudioStreamerStart` runs, it recalculates the buffering window (`recalcBuffering`) to size the ring buffer for the requested latency, resets the stream, acquires the IN/OUT accessors, and pre-fills several seconds of audio via `streamFill`, which copies bytes from the source file through `STM_AccessFileTransfer`. The first block is attached to the channel’s `AudioSample` before the voice is started, ensuring the driver can immediately pull PCM through the installed callbacks.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Streamer.cpp†L328-L363】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Streamer.cpp†L665-L754】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Streamer.cpp†L225-L279】
- **Device-driven consumption.** Every time the DirectSound mixer requests more data, the channel’s `streamNextFrame` callback advances the OUT accessor by the bytes the driver just played, wraps the logical stream position, and exposes the next contiguous slice (`frameData`, `bytesInFrame`) for `AUD_fill_buffer` to copy into the hardware buffer.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Streamer.cpp†L160-L186】 As data is consumed, `STM_AccessAdvance` and `STM_AccessUpdate` propagate availability back to the IN accessor so producers can reuse space without race conditions.【F:Generals/Code/Libraries/Source/WPAudio/AUD_StreamBuffering.cpp†L985-L1094】
- **Background refills and teardown.** The streamer thread polls each registered instance through `service_streams`/`service_stream`, which calls `streamFill` whenever the AS_FILL flag is set; looping streams seek back to `data_start` when EOF is hit, while non-looping streams clear the flag to stop refilling. Stopping or destroying a streamer releases accessors, detaches the channel, and destroys the `STM_STREAM`, guaranteeing no dangling references to the shared buffers remain.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Streamer.cpp†L225-L320】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Streamer.cpp†L499-L754】

## WWAudio device bootstrap and handle ownership
- **2D device selection.** `WWAudioClass::Open_2D_Device(LPWAVEFORMAT)` records the requested playback format, assumes a DirectSound target, and shuts down any existing driver before forcing Miles to favor DirectSound (`DIG_USE_WAVEOUT = FALSE`). It then calls `AIL_waveOutOpen`, checks whether the returned driver is merely emulating DirectSound, and if so closes it and reopens with `DIG_USE_WAVEOUT = TRUE` to fall back to the default waveOut path. Successful opens trigger `Allocate_2D_Handles` and `ReAssign_2D_Handles` so every active sound reacquires a Miles voice under the new driver.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L320-L373】 The overload that accepts stereo/bits/hertz repeatedly halves the sample rate and retries until initialization succeeds or drops below 11.025 kHz, ensuring low-spec hardware still receives a valid format.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L382-L412】
- **2D teardown and handle pools.** `Close_2D_Device` removes playlist-owned handles, releases the cached pool, and closes the Miles driver handle so future retries start clean.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L422-L450】 `Allocate_2D_Handles` clears prior allocations, loops up to `m_Max2DSamples` to call `AIL_allocate_sample_handle`, tags each slot with null user data, and shrinks `m_Max2DSamples` to the actual number granted, while `Release_2D_Handles` returns them to Miles during shutdowns or device swaps.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L1455-L1502】 When a sound requests playback, `Get_2D_Sample` prefers an unused handle, otherwise compares design-time and runtime priority to steal the quietest active voice—freeing the losing sound’s Miles handle before handing it back to the caller.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L1510-L1569】 Playlist utilities such as `ReAssign_2D_Handles` and `Remove_2D_Sound_Handles` iterate active sounds so pooled voices can be reclaimed or reissued whenever the driver changes.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L2009-L2073】
- **3D provider bootstrap.** `Build_3D_Driver_List` walks every Miles 3D provider, probes each one with `AIL_open_3D_provider`, caches the handle/name pairs, and attempts to auto-select known technologies (A3D, EAX, DirectSound, Dolby) before falling back to the first successful entry.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L1661-L1698】 `Select_3D_Device` tears down existing assignments, reopens the chosen provider, reinitializes the `SoundScene`, allocates a fresh pool of 3D handles, and tweaks the global effects level when an EAX-capable driver is detected.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L1753-L1830】 Supporting helpers locate devices by substring (`Find_3D_Device`) and free provider metadata when the list is rebuilt or the system shuts down.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L1885-L1949】
- **3D voice management.** `Allocate_3D_Handles`/`Release_3D_Handles` mirror the 2D logic with `AIL_allocate_3D_sample_handle`, while `Get_3D_Sample` applies the same priority-stealing rules using the Miles 3D user-data slots to track ownership. Playlist passes through `ReAssign_3D_Handles` and `Remove_3D_Sound_Handles` ensure positional voices are returned or rebound whenever providers change.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L1578-L2095】
- **System-level boot/shutdown.** High-level `Initialize` overloads load registry preferences, register custom file I/O callbacks, open the preferred 2D device, and enumerate 3D providers, while `Shutdown` stops timers, flushes playback, frees cached buffers, destroys voice pools, closes drivers, and ultimately calls `AIL_shutdown`. Backend replacements must replicate these entry points so global audio startup and teardown continue to synchronize device choice and handle ownership with the rest of the engine.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L2210-L2326】

## Miles handle wrapper responsibilities
- **2D handles (`Sound2DHandleClass`).** Each instance holds a Miles `HSAMPLE`, reinitializes it through `AIL_init_sample`, and binds decoded audio by passing filenames and raw buffers to `AIL_set_named_sample_file`. Playback control is expressed entirely through Miles—start, stop, resume, and end map directly to `AIL_start_sample`, `AIL_stop_sample`, `AIL_resume_sample`, and `AIL_end_sample`, while volume/pan/loop/pitch accessors forward to the corresponding `AIL_set_sample_*` and query APIs. The class also exposes seek helpers that mirror Miles millisecond queries and persists the engine association via `Set_Miles_Handle` and the `AIL_set_sample_user_data` slots so higher-level code can stuff back pointers for callbacks.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/sound2dhandle.cpp†L46-L368】
- **Streaming handles (`SoundStreamHandleClass`).** Stream voices use both an `HSAMPLE` and an `HSTREAM`. Initialization converts the sample handle into a stream with `AIL_open_stream_by_sample`, then runtime operations route to Miles for playback (`AIL_start_stream`, `AIL_pause_stream`, `AIL_close_stream`) and attribute updates (`AIL_set_stream_pan/volume`, loop counts, playback rate, and millisecond positioning). User-data plumbing reuses the underlying sample handle so queue owners can recover their `AudibleSoundClass` via `AIL_sample_user_data`, and `Set_Miles_Handle` lets WWAudio rebalance streams when voice pools are rebuilt.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/soundstreamhandle.cpp†L46-L365】
- **3D handles (`Sound3DHandleClass`).** Positional voices wrap Miles `H3DSAMPLE`s, feeding buffers through `AIL_set_3D_sample_file` and driving playback with the `AIL_*_3D_sample` family. The helper converts between WWAudio’s millisecond bookkeeping and Miles’ byte offsets when seeking or reporting progress, manages loop counts and playback rate, and mirrors the user-data contract by writing owner tokens with `AIL_set_3D_object_user_data` before storing the handle via `Set_Miles_Handle`.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/sound3dhandle.cpp†L70-L382】
- **Object association.** Higher-level wrappers such as `AudibleSoundClass` and `Sound3DClass` immediately write their `this` pointers into the Miles user-data slots after a handle is assigned so driver callbacks can recover the owning object. When a voice is released, the same helpers clear the slot and tear down the Miles handle so the pool can recycle it safely.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/AudibleSound.cpp†L600-L676】【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/Sound3D.cpp†L520-L557】

## Listener and 3D control expectations
- **Listener handle semantics.** The engine models listeners as lightweight `Sound3DClass` derivatives; when a Miles 3D sample is attached to a `Listener3DClass`, `Initialize_Miles_Handle` recenters the handle, restores a forward/up basis, and stashes the listener pointer in the user-data slot so callbacks can locate the owning object.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/Listener.cpp†L73-L88】 Any backend must provide an equivalent listener object that can publish an orientation transform and expose a stable identity for scene code.
- **Scene-driven listener transforms.** `SoundSceneClass::Collect_Audible_Sounds` keeps the active listener pair synchronized with audible emitters: each primary sound is updated with the main listener transform, while auxiliary sounds (used for split-surround effects) receive the second listener transform before culling decisions hand them to the mixer.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/SoundScene.cpp†L363-L448】 Replacement backends must therefore support at least one listener transform and optionally a secondary listener so audio mixing can weight sounds for alternate viewpoints.
- **Per-sound listener-space updates.** Whenever a listener transform changes, `Sound3DClass::Set_Listener_Transform` caches the matrix and immediately calls `Update_Miles_Transform`, which inverts the listener transform, multiplies it by the emitter transform, and forwards the resulting position/orientation to Miles via `AIL_set_3D_position`/`AIL_set_3D_orientation`.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/Sound3D.cpp†L261-L327】
- **Dynamic spatial attributes.** Position, velocity, and attenuation setters recompute listener-space coordinates and propagate them to Miles—`Set_Position` transforms the new world translation before calling `AIL_set_3D_position`, `Set_Velocity` writes a velocity vector, and the drop-off/max-volume setters translate WWAudio’s scalar radii into Miles’ near/far distance pair.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/Sound3D.cpp†L337-L449】 Combined with the per-frame auto-velocity calculation in `On_Frame_Update`, emitters stay physically coherent even while the listener moves.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/Sound3D.cpp†L200-L224】
- **Handle initialization and effects.** When a 3D handle is (re)claimed, `Sound3DClass::Initialize_Miles_Handle` uploads buffers, reapplies cached gain/pan/loop state, programs attenuation and global effects levels, reapplies pitch, seeks to the saved playhead, and rebinds the user data pointer so callbacks can recycle ownership later.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/Sound3D.cpp†L461-L536】 Handles themselves are drawn from WWAudio’s provider via `Allocate_Miles_Handle`, so a backend swap must source comparable 3D voice objects and preserve that lifecycle.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/Sound3D.cpp†L547-L557】

## Asset and buffer translation requirements
- **Cache-first buffer lookup.** WWAudio routes every asset request through `Get_Sound_Buffer`, which hashes filenames/string IDs, queries the cache (`Find_Cached_Buffer`), and only creates a new `SoundBufferClass` when no entry exists—pulling files from the shared `FileFactory` before falling back to raw-memory helpers.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L456-L502】【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L657-L738】 Backend-neutral loaders must preserve this lookup flow so higher-level systems continue to receive ref-counted buffers regardless of the underlying audio engine.
- **Preload versus streaming selection.** `Create_Sound_Buffer` measures the source file against WWAudio’s 2D/3D size caps and instantiates either a resident `SoundBufferClass` (full PCM preloaded) or a `StreamSoundBufferClass` placeholder that only captures metadata for oversized assets.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L657-L699】 Replacements need an equivalent policy to decide whether to hand the backend a memory-resident buffer or an object that feeds streaming APIs.
- **Miles-driven metadata extraction.** `SoundBufferClass::Determine_Stats` leans on `AIL_WAV_info` to decode sample rate, channel count, bit depth, format, and duration from WAV/ADPCM payloads, and the file/memory loaders always call it after copying bytes into RAM.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/SoundBuffer.cpp†L118-L228】【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/SoundBuffer.cpp†L243-L281】 Stream buffers read only the first 4 KB to seed the same stats so streaming mixers know how to schedule blocks.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/SoundBuffer.cpp†L323-L379】 A new backend must either port this parsing logic (including ADPCM handling) or delegate to the chosen audio library’s loaders to populate equivalent metadata fields.
- **Cache eviction constraints.** `Cache_Buffer` refuses to store buffers larger than half the configured cache, evicts older entries through `Free_Cache_Space`, and tracks total bytes so WWAudio can cap preloaded audio memory.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L602-L699】 Asset translators should respect the same thresholds—or expose tunable limits—to avoid regressing memory usage when Miles is removed.
- **Handle-ready buffer layout.** Miles handles expect contiguous PCM blobs and the original filename for debugging; `Sound2DHandleClass::Initialize` passes both to `AIL_set_named_sample_file` whenever a handle is rebound.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/sound2dhandle.cpp†L70-L85】 Replacement buffers must therefore supply raw audio data, length, and identifying strings in a format the new backend can ingest (e.g., SFML’s `sf::SoundBuffer::loadFromMemory`) so that existing channel code can continue to reinitialize voices without additional glue.

## Backend abstraction design
- **Define a backend facade that mirrors `AudioSystemMaster`.** Introduce an `IAudioBackend` (or extend `AudioSystemMaster`) that exposes `load`, `unload`, `open`, `close`, and `service` entry points, because WPAudio instantiates systems by calling `master->load`, tears them down with `master->unload`, opens devices through `master->open`, and relies on the driver-supplied service callback during mixer ticks.【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L243-L255】【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L1333-L1479】【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L660-L715】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Device.cpp†L321-L365】 This facade should additionally surface thread/service configuration knobs so SFML (or another engine) can either run its own callbacks or let WPAudio continue polling.
- **Model devices separately from the backend.** Preserve an `IAudioDevice` shim that WPAudio can map to logical units, create/destroy alongside `audioCreateDevice`, and query for voice limits. The shim needs to enforce channel caps, coordinate attribute updates, and expose per-channel iterators because `AudioDeviceCreateChannel`, `audioDeviceHandler`, and the driver service loop expect to traverse and update channel lists while honoring the `maxChannels` budget.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Device.cpp†L392-L520】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Device.cpp†L1075-L1136】【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L660-L715】
- **Treat voices as driver-owned objects.** Implement an `IAudioVoice` (or `IAudioChannelBackend`) wrapper whose methods line up with the DirectSound driver vtable: open/close channel, start/stop, pause/resume, liveness checks, attribute updates, buffer queuing, and locking.【F:Generals/Code/Libraries/Source/WPAudio/AUD_DSoundDriver.cpp†L227-L1737】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Channel.cpp†L106-L204】 Higher-level code should obtain these voices from the device shim, store them on `AudioChannel::driver`, and call into them from `AudioChannelStart`, `AudioChannelStop`, and the attribute propagation paths without knowing which backend implements the work.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Channel.cpp†L596-L666】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Device.cpp†L466-L520】
- **Bridge streaming and buffer pumps.** Provide `IAudioStream`/`IAudioQueue` helpers that expose the same callbacks WPAudio’s streamer expects: fetching the next frame, marking frames done, scheduling fills, and pre-buffering data before playback starts. These helpers must coordinate with the backend voice to recycle buffers just like `streamNextFrame`, `streamSampleDone`, `streamFill`, and `service_streams` keep ring buffers fed today.【F:Generals/Code/Libraries/Source/WPAudio/AUD_Streamer.cpp†L160-L320】【F:Generals/Code/Libraries/Source/WPAudio/AUD_Streamer.cpp†L225-L359】 When backed by SFML, the stream shim can translate these calls into `sf::Music` chunk submissions while preserving WPAudio’s buffering policies.
- **Expose buffer and metadata adapters.** Wrap resident audio data in an `IAudioBuffer` that advertises sample rate, channels, duration, and raw PCM spans so WWAudio’s handle classes can keep initializing voices by filename and memory pointer. The adapter can fill its metadata via the existing `SoundBufferClass` pipeline or via the new backend’s decoding utilities, but it must still provide filename, byte count, and PCM accessors because WWAudio reuses them during handle swaps.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/SoundBuffer.cpp†L118-L379】【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/sound2dhandle.cpp†L70-L90】
- **Support listener and spatial hooks.** Ensure the abstraction exposes listener transforms, per-voice spatial attributes, and a user-data channel so 3D and 2D wrappers can continue to project world transforms, push velocities, and attach owner pointers. `Sound3DClass` pushes listener-relative transforms and orientation on every update, while `Listener3DClass` seeds handles with neutral positions and stores the owning object pointer—behaviors the new backend must mirror via explicit APIs for listener state, emitter transforms, and opaque handle metadata.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/Sound3D.cpp†L261-L336】【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/Listener.cpp†L73-L88】【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/AudibleSound.cpp†L600-L676】
- **Retain WWAudio’s voice-pool semantics.** Provide allocation and stealing hooks that WWAudio can call when it needs a fresh 2D/3D voice, mirroring how `Allocate_2D_Handles`, `Release_2D_Handles`, and `Get_2D_Sample` manage Miles handles and enforce priority-based stealing. The abstraction should let WWAudio recycle or evict backend voices, clear user data, and rebind sounds as drivers change, preserving playlist reassignment behaviors during device swaps.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L1455-L1569】【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/WWAudio.cpp†L2009-L2073】
- **Map WWAudio handle wrappers onto the new API.** Update `Sound2DHandleClass`, `SoundStreamHandleClass`, `Sound3DHandleClass`, and listener helpers to depend on the abstraction instead of Miles-specific calls. Each wrapper should translate `Start_Sample`, `Stop_Sample`, attribute setters, and user-data accessors into the corresponding backend methods so WWAudio’s higher-level objects continue to manage state transitions, seek positions, and store owner pointers without DirectSound knowledge.【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/sound2dhandle.cpp†L70-L139】【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/soundstreamhandle.cpp†L46-L365】【F:Generals/Code/Libraries/Source/WWVegas/WWAudio/sound3dhandle.cpp†L70-L382】
